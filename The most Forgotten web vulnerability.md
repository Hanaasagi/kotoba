##本文译自[https://www.exploit-db.com/docs/39434.pdf](https://www.exploit-db.com/docs/39434.pdf)
---
#<center>THE MOST FORGOTTEN WEB VULNERABILITIES</center>
####<center>Written by 0KaL @ WhiteCollarGroup</center>
####<center>Reviewed by WCG147,3du and Neolnvasor</center>
The Most Forgotten Web Vulnerabilities
Written by 0KaL (@0KaL_H4) for WhiteCollarGroup (@WCollarGroup)
Reviewed by WCG147, 3du and NeoInvasor (thanks to Brazilian Cyber Army)
For SystemHacker, #0rch1d and #M0rph
Version: 1.0 published in February, 10 th 2016
#Introduction
PHP的学习周期很短，它的一些特性使得你可以差不多可以写任何的web应用。但是PHP允许程序员来做一些怪诞的事情。我认为一些对于程序员有利的方面，对于初学者来说可能带来许多的头痛，使他们变得抓狂。  
这些我们将要看到的脆弱面值得我们注意。对于黑客，这些不应该的漏洞将会提供整个服务器的权限，但是并不意味着他们不能制造途径。攻击者可以通过社会工程来达到目的。
#Table of contents
###[Attribute-based Cross-site Scripting](#Attribute-based Cross-site Scripting)  
###[Multi-level SQL Injection](#Multi-level SQL Injection)  
###[Cross-site Request Forgery](#Cross-site Request Forgery)  
###[Local File Inclusion](#Local File Inclusion)  
###[Session fixation](#Session fixation)  
###[Session Hijacking](#Session Hijacking)  
###[Internal session stealing](#Internal session stealing) 
###[And now?](#And now?)
<a href="Attribute-based Cross-site Scripting" id="Attribute-based Cross-site Scripting">
#Attribute-based Cross-site Scripting
</a>
你可能已经了解XSS了，你一定从客户端获取到一些HTML代码并保存，之后显示出来。你一定获取到一些html标签，*htmlspecialchars()*并不会帮助我们。最好记住，一些可视文本编辑器的过滤功能会很容易被一些攻击者无效化。你需要在服务器端进行html过滤。  
你会机智地利用html标签的白名单去避免攻击者在你的页面包含iframes或scripts：  
`$content = strip_tags($_POST['content'], '<b><i><u><p><div><img>');`  
但是html事件呢？  
举个栗子，你可以想象如果用户发送了下面的代码会发生什么？（请让我们记住攻击者可以轻松地通过开发者工具如Firebug来绕过可视文本编辑器的转义）
`<img onLoad="javascript:alert('xss');" src="http://placehold.it/350x150" />`  
我们可以看到：我们已经限制了`<script>`标签，但是那并不是唯一的方式在html中去执行Javascript代码。上面的代码会仍然运行，警告框会弹出（如果警告框可以，那窃取cookie和session同样可以发生）。  
**onLoad**事件可以在以下的html标签中使用:  
`<body>, <frame>, <iframe>, <img>, <input type="image">, <link>, <script>,<style>`  
但是要记住，在大部分的html标签的支持下，还有更多的DOM事件可以利用。详见[W3schools](http://www.w3schools.com/jsref/dom_obj_event.asp)  
当然，不只是DOM事件可以造成问题。如果用户只是调皮，也可以通过向style属性插入CSS代码。举个栗子，创建一个写有"Hacked by Haxor"的div来遮盖整个窗口。  
**如何进行防范？**  
你已经看到，strip_tags()是不够的。它需要白名单来过滤html标签和属性。strip_tags()仅仅过滤。不巧的是，PHP并没有过滤属性的函数。幸运的是，有一些外部的选择供我们参考。其中一个就是[HTML Purifier](http://htmlpurifier.org/)。  
它容易上手，能够有效的一处危险的HTML标签和属性。举个栗子：  

    <?php  
        require_once './htmlpurifier/library/HTMLPurifier.auto.php';  
        $dirty_html = '<img onLoad="javascript:alert(\'xss\');"  
        src="http://placehold.it/350x150" /><script> alert(1); </script>';  
        $config = HTMLPurifier_Config::createDefault();  
        $purifier = new HTMLPurifier($config);  
        $clean_html = $purifier->purify($dirty_html);  
        echo $clean_html;  
        /*Will return:  
        <img src="http://placehold.it/350x150" alt="350x150" />  
        */  
    ?>  
另一种方法是向属性进行注入，它会在你向另一个属性中插入用户输入时生效。让我们看一个栗子:      
 
    <?php  
        $link = htmlspecialchars($_GET['link']);  
    ?>
    <a href='<?php echo $link; ?>'>Click here</a> to continue.  
    
如果用户访问yoursite.com/script.php?link=http://google.com'onClick='alert(1); ,会产生如下效果:  
`<a href='http://google.com' onClick='alert(1);'>Click here</a> to continue.`  
造成这种情况的原因是htmlspecialchars()只会将双引号(")替换成`&quot;`,而上面使用了单引号(')。你需要指定ENT_QUOTES来作为第二个参数，使htmlspecialchars()同时将单引号(')、双引号(")转义成实体。  
`$link = htmlspecialchars($_GET['link'], ENT_QUOTES);`  
现在我们将得到:  
`<a href='http://google.com&#039; onClick=&#039;alert(1);'>Click here</a> to continue.`  
当然，some validation with filter_var() is also highly recommended.  
<a href="Multi-level SQL Injection" id="Multi-level SQL Injection">
#Multi-level SQL Injection
</a>  
我们知道有必要去过滤用户的输入，或使用类型转换或使用占位符进行预处理来防止SQL注入，但是SQL注入是变化多端的。  
假设我们有下面的表段：  
Table: "topics"  

| id     | author | title  | text |
|:------:|:------:|:------ |:---- |
| 1      | 2      | Hi     | Hey! |
| 2      | 2      | Hey    | Hi!  |
Table: "users"  

| id   | username | password    |
|:----:|:--------:|:----------- |
| 1    | admin    | (pwd)       | 
| 2    | hacker   | (pwd)       |  
当显示一个topics页面时，你的代码是：  

`$id = (int)$_GET['id']; // protecting!`  
`$qry = your_query_function("SELECT u.username, t.title. t.text FROM topics t LEFT JOIN users u ON t.author=u.id WHERE t.id=$id");`  

但是当你需要显示这个用户的其他topics链接时，如果你的查询语句是这样的：  
`$qry = your_query_function("SELECT u.username, t.title. t.text FROM topics t
LEFT JOIN users u ON u.username='$row[author]'");`  
`$row[author]`直接从数据库中得到，并且你已经使用mysql_escape_string()来进行防护。你真的安全么？**Wrong**  
攻击者在进行注册时，会将他的username设置为  
`' UNION ALL SELECT version(), version() --`  
注册时，你已经在插入数据库前对字符串进行了转义，上面的语句仅仅是躺在数据库中，不会发生注入。然而，一旦攻击者访问他的topics页面。我们查询更多topics的代码会执行，会拼接成如下语句：  
`SELECT u.username, t.title. t.text FROM topics t LEFT JOIN users u ON u.username='' UNION ALL SELECT version(), version() -- '`  
这里二次SQL注入已经成功发生。这是相当费功夫的。但是***when a hacker wants, a hacker does***  
**如何进行防范？**  

*   在对数据库进行查询或插入时，对所有的变量进行防护/类型检测，甚至是从自己的数据库获得的数据。
*   避免在SQL语句中拼接变量，使用占位符和预处理语句进行防护。  

<a href="Cross-site Request Forgery" id="Cross-site Request Forgery">
#Cross-site Request Forgery
</a>
跨站请求伪造(CSRF)指劫持用户，使其无意识地去做某些事情。假设我们有如下表单页：  

    <form action="post.php" method="post">  
        <input name="message" type="text" />  
        <input type="submit" value="Post it now" />
    </form>  
用户输入内容，点击submit按钮。post.php会接收请求，并将message的值进行存储。  
但闲的蛋疼的黑客会写一个简单的html页面，包含如下内容：  

    <iframe id="haxor" style="display: none;" name="haxor" width="300"
    height="150"></iframe>  
    
    <form action="http://your_beautiful_site.com/post.php" method="post"
    target="haxor" id="haxorfrm">
        <input name="message" type="hidden" value="HAXORED BY HAXOR" />
    </form>  
    
    <script type="text/javascript">
        document.getElementById('haxorfrm').submit();
    </script>  
简单的分析:  

*  一个隐藏的iframe，用户看不到它
*  一个带有隐藏输入框的表单，它的target设置为haxor。这样提交后action指定的页面会在隐藏的iframe中加载。
*  js代码会自动提交表单，”HAXORED BY HAXOR“就这样悄无声息的发送到了后端。  
  
让我们想象这样一个场景：黑客将链接发送给受害者。如果受害者没有登陆，什么都不会发生。但是如果有一天他登陆而且点开链接，Σ( ° △ °|||)︴。页面加载，表单通过js代码提交，这一切用户都不会知道。  
**如何进行防范？**   
构造一个token并且每次涉及修改数据的操作都对token进行验证。在显示表格之前，构造一个随机的token，将它存入session。并且写一个隐藏的`<input>`。当表单提交时，你需要对token进行验证，就像这样：  

    <?php  
        session_start();
        $token = md5(uniqid(rand(), true));
        $_SESSION['csrftoken'] = $token;
    ?>  
    
    <form action="post.php" method="post">
        <input type="hidden" name="csrftoken" value="<?php echo $token; ?>" />  
        <input name="message" type="text" />
        <input type="submit" value="Post it now" />
    </form>  
On post.php:  

    <?php
        session_start();
        if($_POST['csrftoken']!=$_SESSION['csrftoken']) {
            echo "CSRF attack detected!";
            exit;
        }
        // save in db, etc
    ?>
当然，如果有好几个表单在你的页面会很烦琐。我写了一个简单的类来帮助你。  

    <?php
        @session_start();
        /*
        * @author @0KaL_H4
        */
        class csrf {
            public function token($action) {
                if (!isset($_SESSION[md5(dirname(__FILE__))]['csrf_tokens'])) {
                    $_SESSION[md5(dirname(__FILE__))]['csrf_tokens'] = array();
                }
                $gen_token = md5(uniqid(rand(), true));
                $_SESSION[md5(dirname(__FILE__))]['csrf_tokens'][md5($action)] = $gen_token;
                return $gen_token;
            }  
            public function verify($action, $check) {
                if (!isset($_SESSION[md5(dirname(__FILE__))]['csrf_tokens'])) {
                    $_SESSION[md5(dirname(__FILE__))]['csrf_tokens'] = array();
                    return false;
                }
                if (isset($_SESSION[md5(dirname(__FILE__))]['csrf_tokens']) AND isset($_SESSION[md5(dirname(__FILE__))]['csrf_tokens'][md5($action)]) AND $_SESSION[md5(dirname(__FILE__))]['csrf_tokens'][md5($action)] == $check) {
                    unset($_SESSION[md5(dirname(__FILE__))]['csrf_tokens'][md5($action)]);
                    return true;
                } else {
                    return false;
                }
            }
        }
    ?>
在你的脚本中包含它然后这样做：  

    <?php
        require 'csrf.class.php';
        $token = csrf::token('post_form'); 
        /*
        create an identifier for your form or action, so you
        can have multiple tokens
        */
    ?>
    <form action="post.php" method="post">
        <input type="hidden" name="csrftoken" value="<?php echo $token; ?>" />
        <input name="message" type="text" />
        <input type="submit" value="Post it now" />
    </form>
On post.php:  

    <?php
        require 'csrf.class.php';
        if(!csrf::verify('post_form', $_POST['csrftoken'])) { // once you verify, the existing token will be removed after being validated
            echo "CSRF attack detected";
            exit;
        }
        // save to db, etc
    ?>  
**没有表单的情况**  
如果你有一些表示具体操作的GET请求，你没加token仍然是危险的。举个栗子：  
`<img src="http://yoursite.com/logout.php" />`  
会挟持用户退出登陆：  
`<img src="http://yoursite.com/admin/delete_post?id=123" />`  
会偷偷地删除一些东西，当然还有更多…………  
我们该怎么办？同样要验证token  

    <?php
        require 'csrf.class.php';
        $token = csrf::token('logout');
    ?>
    <a href="logout.php?token=<?php echo $token; ?>">Logout</a>
    <?php
        require 'csrf.class.php';
        if (!csrf::verify('logout', $_GET['token'])) {
            echo "CSRF attack detected!";
            exit;
        }
        // do logout, etc
    
   ?>  
<a href="Local File Inclusion" id="Local File Inclusion">
#Local File Inclusion
</a> 
PHP的文件包含存在两种：本地文件包含(LFI)和远程文件包含(RFI)。远程文件包含需要开发者格外留意，因为攻击者可以包含远程主机上的PHP webshell。同样本地文件包含也是非常危险的。即使不能够成功窃取服务器上的`/etc/passwd`、`/etc/shadow`文件，也能在服务器内创建PHP来执行。  
Apache将每一次的请求保存在访问日志(access log)文件中。攻击者如果使用NetCat发送下面的请求（web浏览器会将标签转义成为实体）：  

    $ nc yoursite.com 80
    GET /<?print`id`;?> HTTP/1.0       
    (twice enter)
你的web服务器会向攻击者返回404页面，但是你的请求会保存在access log文件中。一旦攻击者发现了某处本地文件包含漏洞，便可以利用access log执行代码。这是一个终端的id命令，当然也可以使用wget命令来下载webshell。（译者注：PHP会将反引号内的字符串当做系统命令来执行）  
**如何进行防范？**   
如果你实在不能预先确定哪些文件可以被包含，至少你要对将要变量的值进行检查。  

    <?php
        $include = basename($_GET['include']);
        if(preg_match("/^([a-z]+)$/",$include) AND file_exists('includes/'.$include.'.php')) {
            include 'includes/'.$include.'.php';
        } else {
            // 404 error
        }  
    ?>  
<a href="Session fixation" id="Session fixation">
#Session fixation
</a>  
session用来存储用户的临时信息。每一个使用session的脚本中，你需要调用`session_start()`函数。之后，一个默认名称为PHPSESSID（名称可以更改）的cookie发送到了客户端。这个cookie存储着一个独一无二的ID来区别用户的每一次访问，获取属于他自己的会话。  
然而通过站点的一些反射型XSS、存储型XSS漏洞很容易能够更改PHPSESSIONID。当然也有可能采取将PHPSESSIONID置于url的方式达到相同目的：  
`http://your_site.com/login.php?PHPSESSID=<a session id here>`  
一旦受害者接收到这条url而且天真地打开它，就会使用攻击者伪造的这条SESSID。这意味着攻击者可以使用某些cookie修改工具(大部分的浏览器已经将这种功能内置于开发者工具中)来使用这条SESSID。此时，攻击者和受害者共享所有的会话。你能想象么？受害者登陆后，攻击者也就登陆了相同的账号，因为他们的session是相同的。这种问题也会出现在用户将url分享给别人的时候(访问链接的人)  
**该如何保护自己？**  
你要确定`php.ini`文件中的`session.user_trans_sid`和`session.user_only_cookies`可以防范攻击：  

    session.use_trans_sid=Off
    session.use_only_cookies=On     //只使用cookie保存session，禁用url传递
现今很多的浏览器都支持了cookie，不再需要将SESSIONID暴露在url中。然而，如果你的应用存在某处XSS漏洞，攻击者就能够使用js代码来执行攻击。当然，你的应用绝不应该出现XSS漏洞，因为这会导致很多安全问题。进一步讲，当用户登陆时建议调用`session_regenerate_id()`来形成新的session ID。因为这对于攻击者来说是不可预测的。  
当然如果有XSS漏洞的话，请修复它。做到了这些，你仍然易受攻击。详情请阅读下一个主题：  
<a href="Session Hijacking" id="Session Hijacking">
#Session Hijacking  
</a>
即使你在用户登陆时生成新的session，如果攻击者能够通过XSS漏洞取得session ID，他便能将自己浏览器的cookie设置为受害人的PHPSESSIONID。刷新一下页面，受害人的会话便又被共享了。  
不幸的是，这里没有任何措施除非修复你的XSS漏洞。但是攻击者也可以通过直接向受害人的电脑伸出邪恶的双手（这时一般是root权限），或者发送可以窃取cookie的木马来达到相同的目的。如果攻击者可以这样做，他完全可以使用键盘记录工具得到用户的password。因为用户缺乏必要的安全意识而导致问题，这和开发者没有半毛钱关系么？Wrong。有些方法可以避免这种情况。其中之一是允许用户使用动态口令(OTP)和两步验证。并没有想象的那么难，有许多现成的PHP类可以使用。搜索一下TOTP算法，你便会明白。  
有这样一句话，security is nerver enough。所以我们再给攻击者制造一些困难。我们可以把浏览器的"User Agent"头存储在用户的session中。如果请求非法，我们将他踢出去。  
我们可以在每一段PHP脚本中包含这段代码(global include)：  

    <?php
        @session_start();
        if (!isset($_SESSION['HTTP_USER_AGENT']) OR $_SESSION['HTTP_USER_AGENT']!=$_SERVER['HTTP_USER_AGENT']) {
            session_destroy();
            header("Location: login.php");
            exit;
    }  
当用户登陆时，我们将存储他"user agent"存储到session。  
`$_SESSION['HTTP_USER_AGENT'] = $_SERVER['HTTP_USER_AGENT'];`  
当然攻击者通过XSS漏洞也可以获取用户的"user agent"，单我们使攻击变得困难了。  
**The answer for session hijacking is: fix up your XSS vulnerability!**  
<a href="Internal session stealing" id="Internal session stealing">
#Internal session stealing
</a>  
当与其他网站共享服务器时，我们需要面对很多风险。一个不经常维护的服务器会使用旧版本的内核。如果同主机的网站被入侵，黑客便可以本地提权或symlink来绕过去入侵你的网站。我们去向服务器公司去寻求保护，或者要求保持备份（或迁移到虚拟主机上去）会遇到很多难题。  
但是有些事情我们可以自己做，不用交给服务器软件。不妨拿session举个栗子。sessions的主要问题是它们默认存储在相同的目录中（通常是tmp目录）。webshell可以读取这些文件（tmp目录的默认权限是777）。  
好在PHP留给我们选择权去将session存储在我们想要的其他目录。我们可以创建一个web站点之外的目录并且通过`.htaccess`禁止访问。确保我们的脚本不会存在LFI漏洞。将这个目录加入`php.ini`文件中。  
`session.save_path = "/home/your_username/sessions_folder/`  
注意这里要用完整路径。你也可以在`session_start()`之前调用`session_save_path()`。如果由于某些原因，你的服务器不允许。你可以使用`session_set_save_handler()`，来创建你自己想要的session处理机制。在这个函数的[文档](http://php.net/session_set_save_handler)中有关于如何创建自定义的session存储机制的例子。例子展示了如何使用数据库来存储session。  
<a href="And now?" id="And now?">
#And now?
</a>
Well, now you know who you’re fighting. Know your enemy, think like him, hack yourself. Stay safe.
